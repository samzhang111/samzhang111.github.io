---
layout: post
title: Programming books I read in 2016
date: 2017-03-16 09:19:00
tag: books
---

# [The Success of Open Source](http://www.amazon.com/Success-Open-Source-Steven-Weber/dp/0674018583)

A detailed origin story for Unix, Linux, and BSD, grounded in the implications of open source for political theory. How, after all, did Linux become the most popular Unix-like kernel when it was run by a large crowd of volunteers, led by a graduate student? Why doesn't the vision of homo economocus play out, where freeloaders parasitize open source projects? 

# [Design Patterns](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8) (AKA the Gang of Four book)

Helpful for a professional programmer to learn the vocabulary from the horse's mouth. I can't tell you how many times someone cited one of these patterns, like, "Let's use a command pattern here," and I was like, "uh-huh", without having any clue what they were talking about. This isn't to say that all the patterns generalized to my experience today. But the ones that did have assimilated into my everyday programmer speech so much that I don't think of them as being formalized here -- like "iterator" and "observer". The examples tend to be tied closely to Java in retrospect, but it's still a good piece to read defensively, so you don't get cornered by people who only talk in design patterns.

# [Clean Code: A handbook of agile software craftsmanship](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882), and [The Pragmatic Programmer](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)

I think software craftsmanship is kind of like "water" for programmers, in the sense of it being invisible and around us. I don't think TDD is going to make you magically a good programmer, but you need to be able to turn on that part of your brain in order to code well. It's also unclear to me whether I really benefit from reading what amounts to self-help books for programmers. I find that the process of seeking these books out has already sort of elevated me to a higher level, and these books just wash over me with obviousness. Like when I write bad code, it's because I'm not _trying_ to write good code. If I were to consciously set out to write good code, it would end up being a lot like what is in these books.

Also, consider the edict Uncle Bob gives that you should consider naming your variables as closely as you do naming your first-born children. I find this to be sort of bad advice, even as a joke, because the actual process of producing good code looks a lot messier to me. I never poop out a perfect variable name the first time through, and I think having more generosity for the trial and error that goes into programming would be wise.

# [Zero Bugs and Program Faster](http://www.amazon.com/Zero-Bugs-Program-Faster-Thompson/dp/0996193308/ref=pd_sim_14_18?ie=UTF8&dpID=61ETcVjivEL&dpSrc=sims&preST=_AC_UL160_SR130%2C160_&refRID=0AJAC2T68XPVVNVRC2W4)

If you haven't noticed by now, my strategy for getting books was basically to find CS/programming related books with 4-5 stars on Amazon. I didn't find this to be that illuminating. Each chapter was only a few paragraphs of truisms, and peppered with examples of famous bugs in obscure programming languages.

# [Hacker's Delight](http://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685/ref=pd_sim_14_11?ie=UTF8&dpID=41KHlIadcWL&dpSrc=sims&preST=_AC_UL160_SR99%2C160_&refRID=1W1KNFXXFHDF1VGENSTJ)

A several hundred page tome about bit twiddling hacks. I thought I loved bit twiddling, but this book proved that I didn't quite love it enough to read this. There aren't any challenge problems or fresh curiosities to keep you hooked -- it just spreads out formulas for doing clever things with bit manipulation. It kind of makes no sense to me why this book exists, but I guess I would find it useful as a reference if I were working on projects that involved squeezing performance out of the tiniest bits.

# [The Nature of Computation](http://www.amazon.com/dp/0199233217/?tag=stackoverfl08-20)

I haven't read it yet, hah. It was too big. But the first chapter was exceptional, and I spent some very rewarding time working through the proofs in the exercises. It's just that if I'm as slow as I seem to be at proving things, then working through this book might take me the next 100 years.

# [The Timeless Way of Building](http://www.amazon.com/Timeless-Way-Building-Christopher-Alexander/dp/0195024028) and [A Pattern Language](http://www.amazon.com/Pattern-Language-Buildings-Construction-Environmental/dp/0195019199/)

I wonder if Christopher Alexander is ever weirded out by the adoration he receives by the programmer community. The Gang of Four book above cites these books as inspirations, as do several other foundational texts. The simplified idea (which may not be too off from the actual idea, since these books were written so straightforwardly, without nuance) is that architecture has attempted too much to create fully-formed spectacles, without consideration for the subtle language that buildings and towns speak when they're allowed to evolve organically. This language would consist of a grammer of parts and pieces of buildings (and towns), without prescribing too many restrictions on what can be done. I find in retrospect that one of my favorite books, [How Buildings Learn](https://www.amazon.com/How-Buildings-Learn-Happens-Theyre/dp/0140139966), by Stewart Brand, is heavily inspired by this.

# [The Design of Everyday Things](http://www.amazon.com/Design-Everyday-Things-Revised-Expanded/dp/0465050654/)

A kindred spirit to the architecture readings above, a classic that makes you look at doors differently, and if you're like me, very helpful in making you a more annoying person since it's inevitable you start criticizing the "design" of everything around you. If you don't know what an "affordance" is, it will explain.

# [The New Turing Omnibus](http://www.amazon.com/The-New-Turing-Omnibus-Excursions/dp/0805071660)

Via a recommendation on Hacker News. A whirlwind tour of forty-some foundational ideas in computer science. It's kind of a bit too much, too fast, for me. I find that I either have previous experience in a subject, and don't learn anything new from a chapter, or it mostly goes over my hand.

# [The Little Schemer](http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992)

I don't know if I can say much higher praise than this, but this book made recursion easy for me! I always thought it was some clever black magic where you had to turn yourself upside down and say the problem to yourself backwards before you fathomed the answer, but it turns out there's a method (or at the very least, a gentle path through practice). I did all the exercises in the book, filled up half a legal pad, and felt quite good about it. I got a bit tired of it toward the end, when they were explaining the Y-Combinator and how recursion is the secret to the universe itself, but maybe you won't ;).

# [Expert C Programming: Deep C Secrets](http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298)

I didn't mean to save the best for last, but this is the best programming book I've ever read. It's hilarious. The only thing harder than recursion is reading C declarations, and this makes that reachable as well. There is quite a dose of humor, since humor is essential for understanding unresolvable tensions in life, such as the C programming language.
